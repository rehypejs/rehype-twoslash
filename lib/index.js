/**
 * @import {Grammar} from '@wooorm/starry-night'
 * @import {ElementContent, Root} from 'hast'
 * @import {} from 'mdast-util-to-hast' // Augmentation.
 * @import {Options} from 'rehype-twoslash'
 * @import {TwoslashNode} from 'twoslash'
 * @import {VFile} from 'vfile'
 * @import {State} from './types.js'
 */

import {createStarryNight} from '@wooorm/starry-night'
import sourceJson from '@wooorm/starry-night/source.json'
import sourceJs from '@wooorm/starry-night/source.js'
import sourceTsx from '@wooorm/starry-night/source.tsx'
import sourceTs from '@wooorm/starry-night/source.ts'
import {ok as assert} from 'devlop'
import {toString} from 'hast-util-to-string'
import {createTwoslasher} from 'twoslash'
import {SKIP, visitParents} from 'unist-util-visit-parents'
import {annotate} from './annotate.js'
import {smallShingleHash} from './shingle.js'
import {
  completion as defaultCompletion,
  error as defaultError,
  highlight as defaultHighlight,
  hover as defaultHover,
  query as defaultQuery
} from './render.js'

/** @type {Readonly<Options>} */
const defaultOptions = {}

/**
 * Default grammars.
 *
 * @type {ReadonlyArray<Readonly<Grammar>>}
 */
// @ts-expect-error: `source.json` is incorrectly seen by TypeScript as JSON.
const defaultGrammars = [sourceJson, sourceJs, sourceTsx, sourceTs]

/**
 * Map files generated by the TS compiler to `starry-night` scopes.
 */
const extensionToScopeMap = new Map([
  ['json', 'source.json'],
  ['js', 'source.js'],
  ['ts', 'source.ts']
])

/**
 * Prefix for language classes.
 */
const prefix = 'language-'

/**
 * Plugin to process JavaScript and TypeScript code with `twoslash`
 * and highlight it with `starry-night`.
 *
 * @param {Readonly<Options> | null | undefined} [options]
 *   Configuration (optional).
 * @returns
 *   Transform.
 */
export default function rehypeTwoslash(options) {
  const settings = options || defaultOptions
  const renderers = settings.renderers || {}
  const directive =
    typeof settings.directive === 'boolean' ? settings.directive : true
  const idPrefix = settings.idPrefix || 'rehype-twoslash-'
  const starryNightPromise = createStarryNight(
    settings.grammars || defaultGrammars
  )
  const twoslash = createTwoslasher(settings.twoslash || undefined)

  /**
   * Transform.
   *
   * @param {Root} tree
   *   Tree.
   * @param {VFile} file
   *   File.
   * @returns {Promise<Root>}
   *   Given tree.
   */
  return async function (tree, file) {
    const starryNight = await starryNightPromise
    /** @type {Map<string, number>} */
    const hashToCount = new Map()

    visitParents(tree, 'element', function (node, parents) {
      const parent = parents.at(-1)
      /* c8 ignore next - element at root never happens with `unified`; only if you do it manually. */
      const index = parent ? parent.children.indexOf(node) : undefined

      if (!parent || index === undefined || node.tagName !== 'pre') {
        return
      }

      const head = node.children[0]

      if (!head || head.type !== 'element' || head.tagName !== 'code') {
        return SKIP
      }

      const classes = head.properties.className

      if (!Array.isArray(classes)) return

      const meta = head.data?.meta || ''
      const directiveTwoslash =
        classes.includes('twoslash') || meta.startsWith('twoslash')
      const directiveNoTwoslash =
        classes.includes('no-twoslash') || meta.startsWith('no-twoslash')

      if (classes.includes('notwoslash')) {
        file.message('Unexpected `notwoslash` class, expected `no-twoslash`', {
          ancestors: [...parents, node],
          place: node.position,
          ruleId: 'missing-dash-class',
          source: 'rehype-twoslash'
        })
      }

      if (meta.startsWith('notwoslash')) {
        file.message(
          'Unexpected `notwoslash` directive, expected `no-twoslash`',
          {
            ancestors: [...parents, node],
            place: node.position,
            ruleId: 'missing-dash-directive',
            source: 'rehype-twoslash'
          }
        )
      }

      if (directiveNoTwoslash || (directive && !directiveTwoslash)) return

      // Cast as we check if it’s a string in `find`.
      const language = /** @type {string | undefined} */ (
        classes.find(function (d) {
          return typeof d === 'string' && d.startsWith(prefix)
        })
      )

      let scope = language
        ? starryNight.flagToScope(language.slice(prefix.length))
        : undefined

      if (
        scope !== 'source.js' &&
        scope !== 'source.ts' &&
        scope !== 'source.tsx'
      ) {
        if (directiveTwoslash) {
          file.message(
            'Unexpected non-js/ts code' +
              (scope ? ' (`' + scope + '`)' : '') +
              ' with twoslash directive, expected JavaScript or TypeScript code',
            {
              ancestors: [...parents, node],
              place: node.position,
              ruleId: 'non-js-ts-with-twoslash',
              source: 'rehype-twoslash'
            }
          )
        }

        return SKIP
      }

      let value = toString(head)
      /** @type {State} */
      const state = {
        count: -1,
        idPrefix: idPrefix + smallShingleHash(value, hashToCount) + '-',
        renderers: {
          completion: renderers.completion || defaultCompletion,
          error: renderers.error || defaultError,
          highlight: renderers.highlight || defaultHighlight,
          hover: renderers.hover || defaultHover,
          query: renderers.query || defaultQuery
        },
        starryNight
      }
      /** @type {Array<TwoslashNode>} */
      let annotations = []

      try {
        const result = twoslash(value, scope === 'source.js' ? 'js' : 'ts')
        value = result.code
        annotations = result.nodes
        scope = extensionToScopeMap.get(result.meta.extension)
      } catch (error) {
        const cause = /** @type {Error} */ (error)
        file.message('Unexpected error running twoslash', {
          ancestors: [...parents, node],
          cause,
          place: node.position,
          ruleId: 'twoslash',
          source: 'rehype-twoslash'
        })
      }

      assert(scope)
      const fragment = starryNight.highlight(value, scope)
      /** @type {Array<ElementContent>} */
      const footer = []
      /** @type {TwoslashNode | undefined} */
      let previous

      for (const annotation of annotations) {
        let skip = false

        // Tags are zero length, so not sure how to render them.
        if (annotation.type === 'tag') {
          skip = true
        }

        // Drop the `hover`, which is likely `any` or at least presumably irrelevant,
        // when a completion follows.
        // For example:
        // ```ts
        // console.e
        //          ^|
        // ```
        // There would be a hover of `any` on the `e` and a completion right
        // after it, which is likely relevant.
        if (
          previous &&
          previous.type === 'completion' &&
          annotation.type === 'hover' &&
          previous.length === 0 &&
          previous.start >= annotation.start &&
          previous.start <= annotation.start + annotation.length
        ) {
          skip = true
        }

        if (!skip) footer.push(...annotate(fragment, annotation, state))

        previous = annotation
      }

      const name = scope.replace(/^source\./, '').replace(/\./g, '-')

      head.properties.className = [
        // With the output language class.
        'language-' + name,
        // Without the input language class:
        ...classes.filter((d) => d !== language)
      ]

      parent.children.splice(index, 1, {
        type: 'element',
        tagName: 'div',
        properties: {className: ['highlight', 'highlight-' + name]},
        children: [
          {type: 'text', value: '\n'},
          {
            // The `<pre>`.
            ...node,
            children: [
              {
                // The `<code>`.
                ...head,
                children: /** @type {Array<ElementContent>} */ (
                  fragment.children
                )
              }
            ]
          },
          ...footer,
          {type: 'text', value: '\n'}
        ]
      })

      return SKIP
    })

    // Note: `Promise<undefined>` or `Promise<void>` as return type seem to fail
    // `unified`’s types.
    return tree
  }
}
